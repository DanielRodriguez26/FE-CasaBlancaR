# Tutorial de Autenticaci√≥n - React 19 + Zustand + TDD

> üìö Tutorial educativo paso a paso para implementar login y autenticaci√≥n en TaskFlow
>
> **Fecha:** 2025-10-04
> **Stack:** React 19, TypeScript, Zustand, Vitest, React Testing Library

---

## √çndice

1. [Paso 1: Fundamentos de Autenticaci√≥n](#paso-1-fundamentos-de-autenticaci√≥n)
2. [Paso 2: Tests para AuthStore (TDD)](#paso-2-tests-para-authstore-tdd)
3. [Paso 2 (Implementaci√≥n): C√≥mo escribir los tests](#paso-2-implementaci√≥n-c√≥mo-escribir-los-tests)

---

## An√°lisis del Proyecto Actual - CasaBlancaR (TaskFlow)

### Stack Tecnol√≥gico Detectado
- **React 19** + TypeScript
- **Zustand** para manejo de estado global (con middleware de persistencia)
- **React Query** (@tanstack/react-query) para estado del servidor
- **React Router DOM v7** para navegaci√≥n
- **Tailwind CSS 4** para estilos
- **Vitest** + React Testing Library para pruebas
- **Socket.io-client** para comunicaci√≥n en tiempo real
- **Axios** para peticiones HTTP
- **Zod** para validaci√≥n de esquemas
- **IndexedDB (idb)** para almacenamiento offline

### Estado Actual de la Autenticaci√≥n

‚úÖ **Ya implementado:**
1. **Store de autenticaci√≥n** (`/src/stores/useAuthStore.ts`)
   - Almacena usuario y estado de autenticaci√≥n
   - Usa `persist` middleware para guardar en localStorage
   - M√©todos: `login()`, `logout()`, `updateUser()`

2. **Tipos de usuario** (`/src/types/user.types.ts`)
   - `User`: datos b√°sicos del usuario
   - `AuthUser`: extiende User con tokens (token + refreshToken)
   - `UserPresence`: para colaboraci√≥n en tiempo real

3. **Protecci√≥n de rutas** (`/src/routes/protected.tsx`)
   - Componente `ProtectedRoute` funcional
   - Redirecci√≥n a `/login` si no autenticado
   - Control de roles (RBAC)

4. **Formulario de login b√°sico** (`/src/features/auth/auth.tsx`)
   - UI del formulario con email/password
   - Manejo de estado local del formulario
   - InputField reutilizable

5. **Configuraci√≥n de rutas**
   - Router configurado con rutas p√∫blicas y protegidas
   - Lazy loading de componentes
   - Redirecci√≥n por defecto a `/login`

‚ùå **Lo que falta implementar:**
1. **L√≥gica de autenticaci√≥n real** - El formulario no est√° conectado al store
2. **Validaci√≥n de formularios** - No hay validaci√≥n con Zod
3. **Servicio de API** - No existe el servicio para hacer login/registro
4. **Manejo de errores** - No hay feedback visual de errores
5. **Gesti√≥n de tokens** - No hay refresh token autom√°tico
6. **Tests** - No hay tests para autenticaci√≥n (TDD pendiente)
7. **Persistencia de sesi√≥n** - No hay verificaci√≥n de token al cargar la app
8. **Logout completo** - Falta limpiar todos los stores

---

## Paso 1: Fundamentos de Autenticaci√≥n

### 1.1 ¬øQu√© es la Autenticaci√≥n y por qu√© la necesitamos?

**Analog√≠a del edificio de oficinas:**

Imagina que tu aplicaci√≥n React es un edificio de oficinas moderno. La autenticaci√≥n es como el sistema de seguridad del edificio:

- **Identificaci√≥n (Qui√©n eres)**: Cuando llegas al edificio, muestras tu credencial al guardia. Esto es el **login** - le dices al sistema qui√©n eres.
- **Verificaci√≥n (Probar que eres t√∫)**: El guardia compara tu foto con tu cara. Esto es la **validaci√≥n de contrase√±a** - demuestras que realmente eres quien dices ser.
- **Pase de acceso (Token)**: Una vez verificado, recibes una tarjeta de acceso temporal. Esto es el **token JWT** - un pase que llevas contigo mientras est√©s en el edificio.
- **Acceso a √°reas (Autorizaci√≥n)**: Tu tarjeta abre ciertas puertas pero no todas. Esto es **RBAC (Role-Based Access Control)** - permisos basados en tu rol.

**¬øPor qu√© no simplemente recordar que iniciaste sesi√≥n?**

Porque las aplicaciones web son **stateless** (sin estado por naturaleza). Cada vez que haces una petici√≥n al servidor, es como si fueras un extra√±o - el servidor no te recuerda. Por eso necesitamos tokens: son como tu tarjeta de identificaci√≥n que muestras en cada petici√≥n.

---

### 1.2 Flujo completo de autenticaci√≥n: La historia de un usuario

Vamos a seguir el viaje de Mar√≠a, una usuaria de tu app:

**Escena 1: Primera visita (Usuario no autenticado)**
```
Mar√≠a abre la app ‚Üí React carga ‚Üí Zustand verifica: "¬øhay usuario guardado?"
‚Üí No hay nadie ‚Üí Redirige a /login
```

**Escena 2: Haciendo login**
```
Mar√≠a escribe email/password ‚Üí Presiona "Iniciar sesi√≥n"
‚Üí Frontend valida el formato (Zod)
‚Üí Env√≠a datos al servidor (Axios)
‚Üí Servidor verifica en base de datos
‚Üí Si es correcto: devuelve { user, token, refreshToken }
‚Üí Frontend guarda en Zustand ‚Üí localStorage lo persiste
‚Üí Redirige a /dashboard
```

**Escena 3: Navegando la app (Sesi√≥n activa)**
```
Mar√≠a va a /tareas ‚Üí ProtectedRoute pregunta: "¬øest√°s autenticada?"
‚Üí Zustand responde: "S√≠, aqu√≠ est√° su token"
‚Üí Permite el acceso ‚Üí Componente carga
```

**Escena 4: Haciendo peticiones protegidas**
```
Mar√≠a crea una tarea ‚Üí Frontend env√≠a POST con el token en headers
‚Üí Servidor verifica el token ‚Üí Si es v√°lido: procesa la petici√≥n
‚Üí Si expir√≥: devuelve 401 ‚Üí Frontend usa refreshToken para renovar
‚Üí Si refreshToken tambi√©n expir√≥: logout autom√°tico
```

**Escena 5: Cerrando sesi√≥n**
```
Mar√≠a presiona "Cerrar sesi√≥n" ‚Üí Frontend llama logout()
‚Üí Zustand limpia el usuario ‚Üí localStorage se borra
‚Üí React Query invalida cach√©s ‚Üí Redirige a /login
```

---

### 1.3 Componentes de un sistema de autenticaci√≥n

Tu sistema de autenticaci√≥n tiene 5 capas, como las capas de una cebolla:

#### Capa 1: UI (Interfaz de Usuario)
- **Qu√© es**: Los formularios de login/registro que ve el usuario
- **Responsabilidades**:
  - Capturar datos (email/password)
  - Mostrar errores visuales
  - Feedback de carga (spinners)
- **En tu proyecto**: `/src/features/auth/auth.tsx`

#### Capa 2: Validaci√≥n (Client-side)
- **Qu√© es**: Verificar que los datos tengan el formato correcto ANTES de enviarlos
- **Por qu√©**: Mejor UX (feedback inmediato) y menos peticiones in√∫tiles al servidor
- **Herramienta**: Zod (ya est√° en tu proyecto)
- **Ejemplo**: "El email debe tener @", "Password m√≠nimo 8 caracteres"

#### Capa 3: Estado Global (Zustand Store)
- **Qu√© es**: El "cerebro" que recuerda si est√°s autenticado
- **Responsabilidades**:
  - Guardar usuario actual
  - Mantener tokens
  - Proveer m√©todos: login(), logout(), updateUser()
- **En tu proyecto**: `/src/stores/useAuthStore.ts` (ya existe!)

#### Capa 4: Comunicaci√≥n con API (Axios + React Query)
- **Qu√© es**: El "mensajero" que habla con el backend
- **Axios**: Para hacer las peticiones HTTP
- **React Query**: Para cachear respuestas y manejar estados (loading, error, success)
- **Falta implementar**: `/src/services/auth.service.ts`

#### Capa 5: Interceptores y Middleware
- **Qu√© es**: "Guardias autom√°ticos" que agregan el token a TODAS las peticiones
- **Por qu√©**: No tienes que acordarte de poner el token manualmente en cada petici√≥n
- **Funcionalidad extra**: Auto-renovaci√≥n de tokens expirados
- **Falta implementar**: Configuraci√≥n de Axios con interceptores

---

### 1.4 Decisiones arquitect√≥nicas: Ventajas y Desventajas

#### ‚úÖ Decisi√≥n 1: Zustand para Estado de Autenticaci√≥n

**Ventajas:**
- **Simplicidad**: Menos boilerplate que Redux (no actions, reducers, dispatchers complicados)
- **TypeScript first**: Excelente inferencia de tipos
- **Tama√±o**: Solo 1.2kb vs 8kb de Redux
- **Middleware de persistencia**: Ya incluido (persist middleware)
- **No necesita Provider**: Funciona como un hook normal

**Desventajas:**
- **DevTools menos maduras**: No tan potentes como Redux DevTools
- **Menos comunidad**: Menos recursos/tutoriales que Redux
- **No es est√°ndar**: En equipos grandes puede preferirse Redux por familiaridad

**¬øCu√°ndo reconsiderar?**
- Si tu app crece a +100 componentes con estado complejo ‚Üí Redux Toolkit
- Si necesitas time-travel debugging avanzado ‚Üí Redux

#### ‚úÖ Decisi√≥n 2: localStorage para Persistencia

**Ventajas:**
- **Persiste sesiones**: El usuario no se desloguea al refrescar
- **Simple**: API nativa del browser, sin librer√≠as extra
- **Sincr√≥nico**: Lectura/escritura instant√°nea

**Desventajas:**
- **Seguridad limitada**: Vulnerable a XSS (JavaScript malicioso puede leerlo)
- **Capacidad**: M√°ximo 5-10MB
- **No accesible desde service workers**: Limita funcionalidad offline avanzada

**Alternativas y cu√°ndo usarlas:**
- **sessionStorage**: Si quieres que la sesi√≥n se cierre al cerrar la pesta√±a
- **IndexedDB**: Para datos sensibles encriptados (ya tienes `idb` instalado!)
- **httpOnly cookies**: La opci√≥n M√ÅS segura (pero requiere m√°s setup en backend)

**Recomendaci√≥n para tu proyecto:**
Guarda solo tokens en localStorage. Datos sensibles del usuario (si los hay) en IndexedDB encriptados.

#### ‚úÖ Decisi√≥n 3: JWT Tokens (Access + Refresh)

**C√≥mo funcionan:**
```
Access Token:
- Vida corta (15 minutos)
- Se env√≠a en cada petici√≥n
- Si lo roban, expira r√°pido

Refresh Token:
- Vida larga (7 d√≠as)
- Solo se usa para pedir un nuevo Access Token
- Guardado m√°s seguro
```

**Ventajas:**
- **Stateless**: El servidor no necesita guardar sesiones en memoria
- **Escalable**: Funciona en m√∫ltiples servidores sin problemas
- **Mobile-friendly**: Mismo sistema para web y app nativa

**Desventajas:**
- **No se pueden revocar f√°cilmente**: Si robas un token v√°lido, funciona hasta que expire
- **Tama√±o**: JWT son m√°s grandes que session IDs (importante en mobile con datos limitados)
- **Complejidad**: Necesitas l√≥gica de refresh autom√°tico

**Alternativa y cu√°ndo usarla:**
- **Session cookies**: Si tu app es solo web y el backend est√° en el mismo dominio (m√°s simple, m√°s seguro)

---

### 1.5 Arquitectura TDD para Autenticaci√≥n

Tu proyecto sigue **TDD (Test-Driven Development)**. Esto significa que para cada funcionalidad:

**Fase RED ‚Üí GREEN ‚Üí REFACTOR**

```
üî¥ RED: Escribir el test (falla porque no hay c√≥digo)
   ‚Üì
üü¢ GREEN: Escribir el m√≠nimo c√≥digo para pasar el test
   ‚Üì
üîµ REFACTOR: Mejorar el c√≥digo manteniendo tests verdes
```

**¬øPor qu√© TDD para autenticaci√≥n espec√≠ficamente?**

La autenticaci√≥n es **cr√≠tica para seguridad**. Un bug aqu√≠ puede:
- Permitir acceso no autorizado
- Exponer datos sensibles
- Romper toda la app

Los tests te dan **confianza** de que:
- Los tokens se manejan correctamente
- Las rutas est√°n protegidas
- Los errores se manejan bien
- No rompes nada al hacer cambios

---

### 1.6 Estructura de carpetas que implementaremos

```
src/
‚îú‚îÄ‚îÄ features/
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îú‚îÄ‚îÄ auth.tsx              # ‚úÖ Ya existe (UI del login)
‚îÇ       ‚îú‚îÄ‚îÄ auth.test.tsx         # ‚ùå Crearemos (tests del componente)
‚îÇ       ‚îú‚îÄ‚îÄ hooks/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ useLogin.ts       # ‚ùå Crearemos (l√≥gica de login)
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ useLogin.test.ts  # ‚ùå Crearemos (tests del hook)
‚îÇ       ‚îî‚îÄ‚îÄ schemas/
‚îÇ           ‚îî‚îÄ‚îÄ auth.schema.ts    # ‚ùå Crearemos (validaci√≥n Zod)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ axios.config.ts       # ‚ùå Crearemos (config + interceptores)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ axios.config.test.ts  # ‚ùå Crearemos (tests)
‚îÇ   ‚îî‚îÄ‚îÄ auth/
‚îÇ       ‚îú‚îÄ‚îÄ auth.service.ts       # ‚ùå Crearemos (llamadas API)
‚îÇ       ‚îî‚îÄ‚îÄ auth.service.test.ts  # ‚ùå Crearemos (tests)
‚îú‚îÄ‚îÄ stores/
‚îÇ   ‚îú‚îÄ‚îÄ useAuthStore.ts           # ‚úÖ Ya existe (mejoraremos)
‚îÇ   ‚îî‚îÄ‚îÄ useAuthStore.test.ts      # ‚ùå Crearemos (tests)
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ protected.tsx             # ‚úÖ Ya existe (mejoraremos)
    ‚îî‚îÄ‚îÄ protected.test.tsx        # ‚ùå Crearemos (tests)
```

---

## Paso 2: Tests para AuthStore (TDD)

### Conceptos de Testing que Aprender√°s

1. **Estructura de tests**: `describe`, `it`, `expect`, `beforeEach`
2. **Mocking**: Crear objetos falsos para simular dependencias
3. **Test isolation**: Cada test debe ser independiente
4. **AAA Pattern**: Arrange (preparar), Act (actuar), Assert (verificar)

### Conceptos de Zustand que Aprender√°s

1. **getState()**: Obtener estado sin usar hooks
2. **setState()**: Modificar estado directamente
3. **Acciones**: Funciones que modifican el estado
4. **Persist middleware**: Guardar/recuperar desde localStorage

### Los 8 Tests que Implementaremos

1. ‚úÖ Estado inicial limpio
2. ‚úÖ Login exitoso
3. ‚úÖ Logout completo
4. ‚úÖ Actualizaci√≥n parcial de usuario
5. ‚úÖ Prevenir actualizaci√≥n sin usuario
6. ‚úÖ Persistencia en localStorage
7. ‚úÖ Limpieza de localStorage
8. ‚úÖ Hidrataci√≥n desde localStorage

---

## Paso 2 (Implementaci√≥n): C√≥mo escribir los tests

### Paso 2.1: Crear el archivo de tests

**Ubicaci√≥n:** `/src/stores/useAuthStore.test.ts`

**Convenci√≥n de nombres:**
- Si el archivo se llama `miArchivo.ts`
- Su test se llama `miArchivo.test.ts`

---

### Paso 2.2: Entender la estructura del archivo

```typescript
// 1. IMPORTS (traemos las herramientas que necesitamos)
import { describe, it, expect } from 'vitest'
import { useAuthStore } from './useAuthStore'

// 2. MOCKS (objetos falsos para simular dependencias)
const mockLocalStorage = { /* ... */ }

// 3. SUITE DE TESTS (agrupamos todos los tests relacionados)
describe('useAuthStore', () => {

  // 4. SETUP (preparaci√≥n antes de cada test)
  beforeEach(() => { /* limpiar todo */ })

  // 5. TESTS INDIVIDUALES
  it('debe hacer X', () => { /* verificar X */ })
  it('debe hacer Y', () => { /* verificar Y */ })
})
```

**Analog√≠a de la receta de cocina:**
1. Ingredientes (imports)
2. Preparar la cocina (mocks)
3. El men√∫ del d√≠a (describe)
4. Lavar los trastes entre platos (beforeEach)
5. Cada platillo (tests individuales)

---

### Paso 2.3: Crear el mock de localStorage

**¬øQu√© es un mock?**
Un mock es un **objeto falso** que imita el comportamiento de algo real.

**¬øPor qu√© lo necesitamos?**
- Los tests corren en Node.js (no en el navegador)
- Node.js **NO tiene** localStorage
- Necesitamos **simular** que existe

```typescript
const mockLocalStorage = (() => {
  // Almac√©n interno (como la "memoria" del localStorage)
  let store: Record<string, string> = {}

  return {
    // Obtener un valor
    getItem: (key: string) => store[key] || null,

    // Guardar un valor
    setItem: (key: string, value: string) => {
      store[key] = value
    },

    // Eliminar un valor
    removeItem: (key: string) => {
      delete store[key]
    },

    // Limpiar TODO
    clear: () => {
      store = {}
    },
  }
})()

// Reemplazamos el localStorage global con nuestro mock
vi.stubGlobal('localStorage', mockLocalStorage)
```

**¬øPor qu√© `store` es un objeto?**
Porque localStorage funciona con pares clave-valor:
- `localStorage.setItem('nombre', 'Ana')` ‚Üí `{ nombre: 'Ana' }`
- `localStorage.getItem('nombre')` ‚Üí busca por clave

---

### Paso 2.4: Patr√≥n AAA de un test

Cada test sigue el patr√≥n **AAA**:

```typescript
it('descripci√≥n de lo que debe hacer', () => {
  // ARRANGE (Preparar)
  // - Configurar el escenario
  const datosDePrueba = { ... }

  // ACT (Actuar)
  // - Ejecutar la acci√≥n que queremos probar
  funcionQueEstamosTesteando(datosDePrueba)

  // ASSERT (Verificar)
  // - Comprobar que el resultado es el esperado
  expect(resultado).toBe(esperado)
})
```

**Analog√≠a:**
- **ARRANGE**: Sacas los ingredientes de la nevera
- **ACT**: Cocinas el platillo
- **ASSERT**: Pruebas si sabe bien

---

### Paso 2.5: Primer test - Estado inicial

```typescript
it('debe inicializar con usuario null y no autenticado', () => {
  // ACT - Obtenemos el estado actual
  const state = useAuthStore.getState()

  // ASSERT - Verificamos
  expect(state.user).toBeNull()
  expect(state.isAuthenticated).toBe(false)
})
```

**Desglose:**
- `useAuthStore.getState()` = preguntarle al store: "¬øQu√© tienes ahora?"
- `expect(state.user).toBeNull()` = "Espero que user sea null"
- `.toBeNull()` = espec√≠fico para null
- `.toBe(false)` = comparaci√≥n estricta (===)

---

### Paso 2.6: Segundo test - Login

```typescript
it('debe autenticar usuario al hacer login', () => {
  // ARRANGE
  const mockUser: AuthUser = {
    id: 1,
    email: 'ana@casablanca.com',
    name: 'Ana Garc√≠a',
    role: 'client',
  }

  // ACT
  useAuthStore.getState().login(mockUser)

  // ASSERT
  const state = useAuthStore.getState()
  expect(state.user).toEqual(mockUser)
  expect(state.isAuthenticated).toBe(true)
})
```

**¬øPor qu√© `toEqual` y no `toBe`?**
- `.toBe()` = compara por referencia (para primitivos)
- `.toEqual()` = compara por contenido (para objetos)

```typescript
// Ejemplo:
const obj1 = { name: 'Ana' }
const obj2 = { name: 'Ana' }

obj1 === obj2 // false (diferentes referencias)
expect(obj1).toEqual(obj2) // true (mismo contenido)
```

---

### Paso 2.7: beforeEach - Limpieza entre tests

```typescript
beforeEach(() => {
  // Limpiamos localStorage
  mockLocalStorage.clear()

  // Reseteamos el store
  useAuthStore.setState({
    user: null,
    isAuthenticated: false,
  })
})
```

**¬øPor qu√© es necesario?**

Sin `beforeEach`:
```typescript
// Test 1: Login
it('login', () => {
  login({ name: 'Ana' })
  expect(user.name).toBe('Ana') // ‚úÖ
})

// Test 2: Estado inicial
it('estado inicial', () => {
  expect(user).toBeNull() // ‚ùå FALLA (Ana sigue ah√≠)
})
```

Con `beforeEach`:
```typescript
// Test 1
beforeEach() // Limpia
it('login', () => { /* ... */ }) // ‚úÖ

// Test 2
beforeEach() // Limpia (incluyendo a Ana)
it('estado inicial', () => { /* ... */ }) // ‚úÖ
```

**Cada test tiene un lienzo en blanco.**

---

### Paso 2.8: Test de Logout

```typescript
it('debe limpiar el estado al hacer logout', () => {
  // ARRANGE - Preparar un usuario logueado
  const mockUser: AuthUser = {
    id: 1,
    email: 'ana@casablanca.com',
    name: 'Ana Garc√≠a',
    role: 'client',
  }

  useAuthStore.setState({
    user: mockUser,
    isAuthenticated: true,
  })

  // ACT - Hacer logout
  useAuthStore.getState().logout()

  // ASSERT - Verificar limpieza
  const state = useAuthStore.getState()
  expect(state.user).toBeNull()
  expect(state.isAuthenticated).toBe(false)
})
```

**Concepto: `setState()` vs `login()`**

- `login(user)` = m√©todo de tu store con l√≥gica compleja
- `setState({ ... })` = m√©todo de Zustand para establecer directamente

En tests usamos `setState()` para **preparar escenarios** sin depender de otros m√©todos.

**¬øPor qu√© no usar `login()` en el ARRANGE?**
Porque estamos testeando `logout()`, no `login()`. Si us√°ramos `login()` y fallara, no sabr√≠amos si el problema es el login o el logout. Usando `setState()` aislamos el test.

---

### Paso 2.9: C√≥digo completo del archivo de tests

Ver archivo completo en: `/src/stores/useAuthStore.test.ts`

---

## Conceptos Clave Aprendidos

### 1. Testing
- ‚úÖ Estructura: `describe`, `it`, `expect`
- ‚úÖ Patr√≥n AAA: Arrange, Act, Assert
- ‚úÖ Mocks: Objetos falsos para dependencias
- ‚úÖ `beforeEach`: Limpieza entre tests
- ‚úÖ `toBe()` vs `toEqual()`: Referencia vs contenido

### 2. Zustand
- ‚úÖ `getState()`: Leer estado sin hooks
- ‚úÖ `setState()`: Establecer estado directamente
- ‚úÖ Acciones: `login()`, `logout()`, `updateUser()`
- ‚úÖ Persist middleware: Auto-guardar en localStorage

### 3. TypeScript
- ‚úÖ `Record<string, string>`: Objeto con claves y valores string
- ‚úÖ `Partial<T>`: Hace todas las propiedades opcionales
- ‚úÖ Type assertions: `!` indica que no es null
- ‚úÖ Optional chaining: `?.` acceso seguro

---

## Preguntas de Comprensi√≥n

### Nivel B√°sico
1. ¬øQu√© hace `beforeEach()` y por qu√© es importante?
2. ¬øCu√°l es la diferencia entre `toEqual()` y `toBe()`?
3. ¬øPor qu√© necesitamos un mock de localStorage?

### Nivel Intermedio
4. ¬øQu√© pasar√≠a si NO limpi√°ramos el estado entre tests?
5. ¬øPor qu√© el test de logout establece primero un usuario autenticado?
6. ¬øQu√© significa "inmutabilidad parcial" en `updateUser()`?

### Nivel Avanzado
7. ¬øPor qu√© el test de hidrataci√≥n requiere un enfoque diferente?
8. ¬øQu√© otros casos edge podr√≠as testear para `updateUser()`?
9. ¬øC√≥mo testear√≠as un error de red al hacer login con una API real?

---

## Pr√≥ximos Pasos

### Fase RED üî¥ (Actual)
1. ‚úÖ Crear archivo `/src/stores/useAuthStore.test.ts`
2. ‚úÖ Copiar c√≥digo de tests
3. ‚úÖ Ejecutar: `npm run test`
4. ‚úÖ Ver tests FALLAR (esto es correcto!)

### Fase GREEN üü¢ (Siguiente)
5. Implementar/mejorar c√≥digo en `useAuthStore.ts`
6. Hacer que los tests pasen uno por uno
7. Verificar cobertura de tests

### Fase REFACTOR üîµ
8. Optimizar c√≥digo manteniendo tests verdes
9. Agregar casos edge adicionales
10. Documentar decisiones

---

## Referencias

- [Vitest Documentation](https://vitest.dev/)
- [Zustand Testing Guide](https://github.com/pmndrs/zustand#testing)
- [React Testing Library](https://testing-library.com/react)
- [TDD Best Practices](https://kentcdodds.com/blog/common-mistakes-with-react-testing-library)

---

**√öltima actualizaci√≥n:** 2025-10-04
**Autor:** Tutorial interactivo con Claude Code
